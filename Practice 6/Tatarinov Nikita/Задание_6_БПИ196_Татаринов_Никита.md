## Задание 6 
 
* Для Олимпийских игр 2004 года сгенерируйте список (год рождения, количество игроков, количество золотых медалей), содержащий годы, в которые родились игроки, количество игроков, родившихся в каждый из этих лет, которые выиграли по крайней мере одну золотую медаль, и количество золотых медалей, завоеванных игроками, родившимися в этом году. 
 
Для начала выделяем события, которые произошли на Олимпийских играх 2004-го года. 
 
```sql 
SELECT event_id FROM events WHERE olympic_id = 'ATH2004'; 
``` 
![image](https://user-images.githubusercontent.com/59981377/139534696-b042d1ba-5dbf-4d2b-8aff-1f72975ec723.png) 
 
Объединяем эту получившуюся таблицу с таблицей результатов results, оставляя только те строки, в которых равны идентификаторы событий event_id и медаль участника является золотой. Далее, группируем строки по идентификатору игрока player_id и считая медали. Таким образом, золотых медалистов, первой столбец которой -- идентификаторы этих золотых медалистов, а второй -- количетсва их золотых медалей на олимпиаде 2004. 
  
```sql 
SELECT player_id, COUNT(medal) as num_of_gold_medals 
FROM results, (SELECT event_id FROM events WHERE olympic_id = 'ATH2004') as events2004 
WHERE results.event_id = events2004.event_id AND results.medal = 'GOLD' GROUP BY player_id; 
``` 
![image](https://user-images.githubusercontent.com/59981377/139534662-6b49d022-3d9c-49fb-80d0-e7fd852204cf.png) 
 
Объединяем таблицу золотых медалистов 2004-го года с таблицей игроков players, оставляя только те строки, в которых идентификаторы игроков player_id равны. Далее, группируем строки по году рождения игроков и оставляем в таблице следующие столбцы: год рождения игроков; количество игроков, родившихся в соответствующий год; суммарное количество медалей этих игроков. Получаем искомую таблицу. 
 
```sql 
SELECT EXTRACT(YEAR FROM players.birthdate) as birthdate_year, COUNT(gold_medalists.player_id) num_of_gold_medalists, 
       SUM(gold_medalists.num_of_gold_medals) as num_of_gold_medals 
FROM players, 
     (SELECT player_id, COUNT(medal) as num_of_gold_medals 
     FROM results, (SELECT event_id FROM events WHERE olympic_id = 'ATH2004') as events2004 
     WHERE results.event_id = events2004.event_id AND results.medal = 'GOLD' GROUP BY player_id) 
         as gold_medalists 
WHERE gold_medalists.player_id = players.player_id 
GROUP BY birthdate_year ORDER BY birthdate_year; 
``` 
![image](https://user-images.githubusercontent.com/59981377/139535007-a14048e6-499a-4c9c-8d99-686091029561.png) 
 
* Перечислите все индивидуальные (не групповые) соревнования, в которых была ничья в счете, и два или более игрока выиграли золотую медаль. 
 
Для начала отберём индивидуальные события. 
```sql 
SELECT event_id, name FROM events WHERE is_team_event = 0; 
``` 
![image](https://user-images.githubusercontent.com/59981377/139537861-22aa80f7-5e91-445c-b672-4619f40d691d.png) 
 
Теперь объединим получившуюся таблицу с таблицей результатов results, оставляя только те строки, в которых идентификаторы событий event_id равны, а медали являются золотыми. Сгруппируем строки по идентификатору event_id и имени name события, посчитав количество золотых медалей для каждого события. Отделим только те события, у которых больше одной золотой медали. Получаем искомую таблицу. 
 
```sql 
SELECT results.event_id, individual_events.name FROM results, 
             (SELECT event_id, name FROM events WHERE is_team_event = 0) as individual_events 
WHERE results.event_id = individual_events.event_id AND results.medal = 'GOLD' 
GROUP BY results.event_id, individual_events.name 
HAVING COUNT(medal) > 1 
ORDER BY results.event_id; 
``` 
![image](https://user-images.githubusercontent.com/59981377/139538141-2ff40c1e-74bf-45c3-b6c9-c500f59d4adf.png) 
 
* Найдите всех игроков, которые выиграли хотя бы одну медаль (GOLD, SILVER и BRONZE) на одной Олимпиаде. (player-name, olympic-id). 
 
Для начала разберём следующий запрос.
 
```sql 
SELECT DISTINCT players.player_id, events.olympic_id 
FROM players 
         JOIN results ON players.player_id = results.player_id 
         JOIN events ON results.event_id = events.event_id; 
``` 
 
В этом запросе объединяются 3 таблицы по идентификатору игрока player_id и идентификатору olympic_id. Далее выбираются строки с уникальной парой идентификатора участника player_id и идентификатора олимпиады olympic_id. Эта таблица является почти искомой, где вместо имени игрока присутствует его идентификатор. Почему нельзя сразу взять имя? 
Дело в том, что если заменить идентификатор на имя, то из таблицы пропадёт часть строк, если в таблице есть разные игроки (разные player_id), но с одинаковыми именами (полные тёзки). Если убрать DISTINCT и оставить имя, то будут лишние строки, так как один часть игроков приняла участие в разных дисциплинах внутри одной олимпиады. 
Получаем таблицу, в которой надо заменить идентификаторы на имена, для чего приходится ещё раз объединить полученную таблицу с таблицой игроков. Получаем искомую таблицу. 
 
```sql 
SELECT players.name, almost_result.olympic_id 
FROM players, 
     (SELECT DISTINCT players.player_id, events.olympic_id 
      FROM players 
               JOIN results ON players.player_id = results.player_id 
               JOIN events ON results.event_id = events.event_id) 
         as almost_result 
WHERE players.player_id = almost_result.player_id 
ORDER BY players.name; 
``` 
![image](https://user-images.githubusercontent.com/59981377/139541948-56a61b78-704a-4cd0-9ae8-12456b8eb348.png) 
 
Заметим, что в таблице нет полных тёзок, в связи с чем следующий запрос даёт тот же результат. 
 
```sql 
SELECT DISTINCT players.name, events.olympic_id 
FROM players 
         JOIN results ON players.player_id = results.player_id 
         JOIN events ON results.event_id = events.event_id 
ORDER BY players.name; 
``` 
 
