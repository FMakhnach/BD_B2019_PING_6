**Задача 1**

DBMS выполняет следующий запрос:

SELECT \* FROM emp WHERE salary = 200;

Предположим, у вас есть индекс B-дерева "emp.salary". Кроме того,
предположим, что таблица содержит 100 миллионов кортежей, хранящихся на
1 миллионе страниц на диске (т.е. в среднем 100 кортежей на страницу).
Далее предположим, что у вас имеется бесконечное количество доступной
основной памяти и что все B-дерево изначально находится в основной
памяти, в то время как ни одна страница таблицы не находится в основной
памяти. Предположим, что произвольный доступ к диску занимает 28
миллисекунд, в то время как последовательный доступ к диску занимает
всего 0,28 миллисекунды.

Примем как n – количество записей, удовлетворяющих условию “salary =
200”, m – число страниц = 10\^(8-2)=10\^6, T1 – время последовательного
доступа = 0.28, T2 – время случайного доступа = 28

А) Определите стоимость (как общее время доступа к жесткому диску)
ответа на этот запрос при использовании B-дерева для ответа на запрос.
Для этого укажите формулу, которая получает в качестве параметра
количество кортежей с содержимым 200.

T = T2 \* m \* (1 – (1 – 1/m)\^n)

Б) Для каких значений параметров (количество сотрудников с содержанием
200) использование B-дерева было бы выгоднее по сравнению с полным
сканированием таблицы? Насколько лучше было бы сканирование полной
таблицы, чем сканирование индекса, если бы все 100 миллионов сотрудников
имели зарплату 200?

T3 – время полного сканирования = T2 + T1 \*(m - 1) = 280027.72

T должно быть меньше T3 =&gt; 28 \* 10\^6 \* (1 – (1 – 1/10\^6)\^n) &lt;
T3

n &lt;= 10051

**Задача 2**

Для каждого из следующих операторов укажите максимальный размер буфера
основной памяти, который он может использовать, и минимально возможный
размер буфера основной памяти, оба в зависимости от размера ввода.

Примем как Mem1 – размер памяти первой таблицы, Mem2 – размер памяти
второй таблицы. Mem1 =&gt; Mem2

-   Nested-loop Join

-   Максимальная память – Mem1+Mem2

-   (Grace) Hash Join

-   Максимальная память – Mem1+Mem2

-   Sort Merge Join

-   Максимальная память – Mem1+Mem2

-   Table Scan

-   Максимальная память – Mem2

-   Index Scan (Доступ к таблице с помощью B-дерева. Внимание: вам нужны
    два буфера: один для B-дерева и один для блоков таблицы)

-   Максимальная память – Mem2+размер B-дерева

Какую стратегию замены вы бы использовали?

Sort Merge Join, если время предварительной сортировки списков
небольшое.

**Задача 3**

Предположим, у нас есть следующая реляционная схема:

Customer(Cid, Name)

Order(Oid, Customer, Volume)

Существует 1000 кортежей клиентов и 100000 кортежей заказов. Размер
каждого кортежа составляет 100 байт.

Кроме того, предположим, что у нас есть следующий запрос, который
запрашивает общий объем заказов Клиента(Customer) по имени “Alex”.:

SELECT sum(o.Volume)FROM Customer c, Order o

WHERE c.Cid = o.Customer AND c.Name = “Alex”;

-   а) Переведите этот SQL-запрос в выражение реляционной алгебры.
    (Подсказка: вы можете использовать функцию sum.)

-   sum(project\[Order.Volume\]( select\[Customer.Name = 'Alex'\](
    join\[Customer.Cid = Order.Customer\](Customer, Order) ) ) )

-   б) Объясните, как вы будете реализовывать каждый оператор, т.е.
    ипользуйте ключевое слово, которое определяет, какой алгоритм вы
    будете использовать для реализации оператора. (Например, 2-фазная
    внешняя сортировка (2-Phase External Sort))

-   sum – сложение всех полученныхзначений

-   project – выбор нужных столбцов

-   select – фильтрация кортежей по условию

-   join - Nested Loop Join

-   в) Для каждого оператора укажите объем основной памяти, который вы
    бы выделили. Почему? Сколько памяти вам нужно для обработки всего
    запроса?

**Задача 4**

Предположим, у нас есть следующий запрос:

SELECT \*FROM R, S, T

WHERE R.rid = S.sid AND S.sid = T.tid AND T.tid = R.rid

-   а) Укажите 3 разных плана запроса для этого запроса (join method).

> R JOIN1 (S JOIN2 T): JOIN1=Nested Loops Join, JOIN2 = Grace Hash Join
>
> (R JOIN1 S) JOIN2 T: JOIN1=Nested Loops Join, JOIN2 = Sort Merge Join
>
> (R JOIN1 T) JOIN2 S: JOIN1=Indexed Nested Loops Join, JOIN2 = Grace
> Hash Join

-   б) Для каждого данного плана в предыдущей части укажите размер
    каждой таблицы, чтобы каждый план был оптимальным.

-   в) Возьмите один из планов из предыдущей части и предположите, что
    ни одна из таблиц не помещается в основную память, т.е. память
    составляет не более половины размера самой маленькой таблицы. В этих
    условиях, как вы распределяете буферы? Какова будет ваша политика
    замены страниц?
