### Задача 1

Пусть:

- `k` - количество записей, у которых `salary = 200`;
- `m = 10^8 / 100 = 10^6` - кол-во страниц;
- `t_seq = 0.28` - время последовательного доступа;
- `t_rnd = 28` - время случайного доступа.

а) `t_idx(k) = t_rand * m(1 - (1 - 1/m)^k)`.

б) Время на полное сканирование: `t_scan = t_rand + t_seq * (m - 1) = 28 + 0.28 * (10^6 - 1) = 280027.72`.

Тогда можно найти такое `k'`, что `t_idx(k') < t_scan`. Т.к. выражение отвратительное, нашёл крайнее `k'`
скриптом: `10051`.

Ответ:

* а) `t_rand * m(1 - (1 - 1/m)^k)`;
* б) `k' <= 10051`

### Задача 2

Для каждого из следующих операторов укажите максимальный размер буфера основной памяти, который он может использовать, и
минимально возможный размер буфера основной памяти, оба в зависимости от размера ввода.

* Nested-loop Join
* (Grace) Hash Join
* Sort Merge Join
* Table Scan
* Index Scan  (Доступ к таблице с помощью B-дерева. Внимание: вам нужны два буфера: один для B-дерева и один для блоков
  таблицы)

Какую стратегию замены вы бы использовали?

-------
Пусть размеры таблиц есть `S` и `T`, `S <= T`. Размер блока одного чтения с диска = `B`.

Я не учитываю нигде память под результат, во всех случаях это в худшем `S*T`. Но кажется разумнее использовать
динамические структуры данных / модель итератора для представления результата.

* Nested-loop Join:
    * Максимальный размер буфера = `(S + T)` (выгрузка двух таблиц в основную память).
    * Минимальный размер буфера = `2 * B` (чтение по одному блоку для каждой таблицы).
* (Grace) Hash Join
    * Максимальный размер буфера = `(S + T)` (выгрузка двух таблиц в основную память).
    * Требует загрузку в память меньшей таблицы (`S`). Преобразует её в хэш-таблицу, что тоже может нести некоторые
      накладные расходы по памяти. Также необходим блок для выгрузки второй таблицы. Итого выходит `S + B`.
* Sort Merge Join
    * Максимальный размер буфера = `(S + T)` (выгрузка двух таблиц в основную память).
    * Минимальный размер буфера = 2 ячейки.
* Table Scan
    * Максимальный размер буфера = `S` (выгрузка всей таблицы в основную память).
    * Минимальный размер буфера = `B` (выгрузка таблицы по одному блоку).
* Index Scan  (Доступ к таблице с помощью B-дерева. Внимание: вам нужны два буфера: один для B-дерева и один для блоков
  таблицы)
    * Максимальный размер буфера = размер B-дерева + `S` (выгрузка всей таблицы в основную память).
    * Минимальный размер буфера = размер вершины B-дерева + `B` (выгрузка таблицы по одному блоку).

### Задача 3

```sql
SELECT sum(o.Volume)
FROM Customer c,
     Order o
WHERE c.Cid = o.Customer
  AND c.Name = “Alex”; 
```

* а)

```
sum(
  project[Order.Volume](
    select[Customer.Name = 'Alex'](
      join[Customer.Cid = Order.Customer](Customer, Order)
    )
  )
)
```

* б)
    1. select: фильтрация кортежей по предикату. Проверяем каждый кортеж, помещаем удовлетворяющие предикату кортежи в
       результат;
    2. project: выбор необходимых столбцов (Volume и Customer для Order, Name и Cid для Customer);
    3. join: Nested Loop Join (слияние вложенными циклами) в предположении, что индексов нет;
    4. sum: сложение в цикле всех значений Volume у полученных кортежей;

* в) Сильно зависит от способа хранения. Буду считать, что индекса нет.

  Первым действием начитал бы меньшую таблицу (`Customer`), совместив с фильтрацией по имени и проекцией. Тогда в худшем
  случае понадобится `page_size + 1000 * (size(Customer.Name) + size(Customer.Cid))`. Здесь `page_size` - размер
  страницы в байтах, в этой памяти будет храниться читаемая страница. Оставшаяся часть - буфер для отфильтрованных
  значений, т.е. `Customer`-ов с именем `Alex`.

  Следующий шаг - Nested Loop Join. Его в идеале можно совместить с проекцией на `Order.Volume` и подсчётом суммы. В
  этом случае понадобится всего лишь 1 ячейка памяти для результата (суммы) и `page_size` для начитки второй
  таблицы (`Order`). Память `page_size` можно взять из предыдущего шага.

  В этом случае суммарно получается `page_size + 1000 * (size(Customer.Name) + size(Customer.Cid)) + sum_size`. Могу
  попробовать взять цифры из головы и прикинуть результат: `page_size` = 8 Кб, `size(Customer.Name)` = 32
  байт, `size(Customer.Cid)` = 8 байт, `result_size` = 8 байт. Тогда итого: 8 Кб + 1000 * (32 байт + 8 байт) + 8 байт ~=
  48 Кб.

  Очевидно, если не совмещать операторы, но выполнять их последовательно, потребуется существенно больше памяти.

### Задача 4

```sql
SELECT *
FROM R,
     S,
     T
WHERE R.rid = S.sid
  AND S.sid = T.tid
  AND T.tid = R.rid 
```

а) Укажите 3 разных плана запроса для этого запроса (join method).

```
1. (R JOIN S) JOIN T: JOIN=Nested Loops Join
2. (R JOIN T) JOIN S: JOIN=Nested Loops Join
3. (S JOIN T) JOIN R: JOIN=Nested Loops Join
```

б) Для каждого данного плана в предыдущей части укажите размер каждой таблицы, чтобы каждый план был оптимальным.

```
1. R = 10, S = 100, T = 1000
2. R = 10, S = 1000, T = 100
3. R = 1000, S = 10, T = 100
```
